/* Flux - generated by esbuild */
var T=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var O=Object.prototype.hasOwnProperty;var B=(l,e)=>()=>(l&&(e=l(l=0)),e);var $=(l,e)=>{for(var t in e)T(l,t,{get:e[t],enumerable:!0})},W=(l,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of U(e))!O.call(l,s)&&s!==t&&T(l,s,{get:()=>e[s],enumerable:!(n=R(e,s))||n.enumerable});return l};var V=l=>W(T({},"__esModule",{value:!0}),l);var k={};$(k,{showInstallWarning:()=>M});function M(l){return new Promise(e=>{let t=!1,n=s=>{t||(t=!0,e(s))};new E(l,n).open()})}var A,j,E,I=B(()=>{A=require("obsidian"),j=`Flux will become the only source of truth for your vault.

After successful setup, all changes should go through Flux. Disable other sync solutions (e.g. iCloud, Dropbox, Obsidian Sync) for this vault.

By enabling Flux, you acknowledge that Flux will be the central source of truth.`,E=class extends A.Modal{constructor(t,n){super(t);this.onResult=n}onOpen(){let{contentEl:t}=this;t.empty(),t.createEl("h2",{text:"Flux - Source of Truth"}),t.createEl("p",{text:j});let n=t.createDiv({cls:"flux-modal-buttons"});n.createEl("button",{text:"Cancel"}).onclick=()=>{this.onResult(!1),this.close()};let s=n.createEl("button",{text:"I understand, enable Flux"});s.addClass("mod-cta"),s.onclick=()=>{this.onResult(!0),this.close()}}onClose(){this.onResult(!1)}}});var J={};$(J,{default:()=>S});module.exports=V(J);var y=require("obsidian");var p=require("obsidian"),N={endpoint:"",username:"",password:"",syncIntervalSeconds:30,fluxFolder:"Flux",enabled:!1,acknowledgedWarning:!1};function L(l){return(l||"").trim().replace(/^\/|\/$/g,"")}var F=class extends p.PluginSettingTab{constructor(t,n){super(t,n);this.plugin=n}display(){let{containerEl:t,plugin:n}=this;t.empty();let s=i=>{Object.assign(n.settings,i),n.saveSettings()};new p.Setting(t).setName("Endpoint URL").setDesc("Flux server URL (e.g. https://flux.shaun.zip)").addText(i=>i.setPlaceholder("https://flux.example.com").setValue(n.settings.endpoint).onChange(r=>s({endpoint:r.trim()}))),new p.Setting(t).setName("Username").setDesc("Basic Auth username").addText(i=>i.setPlaceholder("username").setValue(n.settings.username).onChange(r=>s({username:r}))),new p.Setting(t).setName("Password").setDesc("Basic Auth password").addText(i=>i.setPlaceholder("password").setValue(n.settings.password).onChange(r=>s({password:r}))),new p.Setting(t).setName("Flux folder").setDesc("Only sync files in this folder (e.g. Flux). Empty = whole vault.").addText(i=>i.setPlaceholder("Flux").setValue(n.settings.fluxFolder).onChange(r=>s({fluxFolder:L(r||"")}))),new p.Setting(t).setName("Pull interval (seconds)").setDesc("How often to pull (default 30)").addText(i=>i.setPlaceholder("30").setValue(String(n.settings.syncIntervalSeconds)).onChange(r=>{let o=Number.parseInt(r,10);!Number.isNaN(o)&&o>0&&(s({syncIntervalSeconds:o}),n.restartPullInterval())})),new p.Setting(t).setName("Enable sync").setDesc("Flux will become the only source of truth.").addToggle(i=>i.setValue(n.settings.enabled).onChange(async r=>{if(r&&!n.settings.acknowledgedWarning){let{showInstallWarning:o}=await Promise.resolve().then(()=>(I(),k));if(!await o(this.app))return i.setValue(!1);s({acknowledgedWarning:!0})}s({enabled:r}),n.setSyncEnabled(r)}))}};var u=require("obsidian");var G=500;function v(l){let e=0;for(let t=0;t<l.length;t++)e=(e<<5)-e+l.charCodeAt(t)|0;return`sha256:${Math.abs(e).toString(36)}${l.length}`}function C(l){return(l||"").trim().replace(/^\/|\/$/g,"")}function g(l){let e=l instanceof Error?l:new Error(String(l)),t=e.cause;return t instanceof Error?t.message:e.message}var x=class{constructor(e,t){this.pushDebounce=new Map;this.applyingPull=!1;this.abortController=null;this.settings=e,this.vault=t}updateSettings(e){this.settings=e}get baseUrl(){let e=this.settings.endpoint.trim();return e?(!e.startsWith("http://")&&!e.startsWith("https://")&&(e=`${e.startsWith("localhost")||e.startsWith("127.0.0.1")?"http":"https"}://${e}`),e.replace(/\/$/,"")):""}inScope(e){let t=C(this.settings.fluxFolder);return!t||e===t||e.startsWith(`${t}/`)}async ensureParentFolders(e){let t=e.includes("/")?e.replace(/\/[^/]+$/,""):"";if(!t)return;let n=t.split("/").filter(Boolean),s="";for(let i of n)s=s?`${s}/${i}`:i,this.vault.getAbstractFileByPath(s)||await this.vault.createFolder(s)}async api(e,t={}){var m;if(!this.baseUrl)throw new Error("Flux endpoint not configured");let n={"Content-Type":"application/json"},{username:s,password:i}=this.settings;(s||i)&&(n.Authorization=`Basic ${btoa(`${s}:${i}`)}`);let r=this.baseUrl+e,o=await(0,u.requestUrl)({url:r,method:(m=t.method)!=null?m:"GET",body:t.body,headers:n}),f=async()=>{let h=o.json;if(typeof h=="function"){let w=h();return w instanceof Promise?w:Promise.resolve(w)}return h!=null&&typeof h.then=="function"?h:typeof h=="string"?JSON.parse(h):h};return{ok:o.status>=200&&o.status<300,status:o.status,json:f}}async pushFile(e){if(this.applyingPull||!this.settings.enabled||!this.baseUrl||e.extension!=="md"||!this.inScope(e.path))return;let t=e.path,n=this.pushDebounce.get(t);n&&clearTimeout(n),this.pushDebounce.set(t,setTimeout(async()=>{this.pushDebounce.delete(t);try{let s=await this.vault.read(e),i=await this.api("/push",{method:"POST",body:JSON.stringify({files:[{path:t,content:s,hash:v(s)}]})});if(!i.ok)throw new Error(`Push failed: ${i.status}`);new u.Notice(`Flux: pushed ${t}`)}catch(s){console.error("[Flux] push error:",s),new u.Notice(`Flux: push failed \u2014 ${g(s)}`)}},G))}async pushFiles(e){for(let t of e)await this.pushFile(t)}async pushAllNow(e){if(!this.settings.enabled||!this.baseUrl||this.applyingPull)return;let t=[];for(let s of e){if(s.extension!=="md"||!this.inScope(s.path))continue;let i=await this.vault.read(s);t.push({path:s.path,content:i,hash:v(i)})}if(t.length===0)return;let n=await this.api("/push",{method:"POST",body:JSON.stringify({files:t,deleted:[]})});if(!n.ok)throw new Error(`Push failed: ${n.status}`)}async pull(){var e,t,n;if(!(!this.settings.enabled||!this.baseUrl)){(e=this.abortController)==null||e.abort(),this.abortController=new AbortController;try{let s=await this.api("/pull",{method:"GET"}),i=await s.json();if(!s.ok){let a=typeof i=="object"&&i!=null&&"error"in i?String(i.error):"";throw new Error(`Pull failed: ${s.status}${a?` \u2014 ${a}`:""}`)}this.applyingPull=!0;let r=0,o=0,f=Array.isArray(i.files)?i.files:[];console.log("[Flux] pull response:",f.length,"files,",(n=(t=i.deleted)==null?void 0:t.length)!=null?n:0,"deleted");try{for(let a of i.deleted||[]){let c=typeof a=="string"?a.trim().replace(/\\/g,"/"):"";if(!c||!this.inScope(c))continue;let d=this.vault.getAbstractFileByPath(c);d&&(await this.vault.delete(d),o++)}for(let a of f){if(!a||typeof a.path!="string"||typeof a.content!="string"){a&&(typeof a.path!="string"||typeof a.content!="string")&&console.warn("[Flux] skip file: missing path or content",a);continue}let c=a.path.trim().replace(/\\/g,"/");if(!this.inScope(c)){console.log("[Flux] skip (out of scope):",c,"folder:",C(this.settings.fluxFolder));continue}let d=this.vault.getAbstractFileByPath(c);if(d&&d instanceof u.TFile){let D=await this.vault.read(d);v(D)!==a.hash&&(await this.vault.modify(d,a.content,{}),r++)}else await this.ensureParentFolders(c),await this.vault.create(c,a.content,{}),r++}}finally{this.applyingPull=!1}let m=new Set(f.map(a=>a.path.trim().replace(/\\/g,"/"))),h=new Set((i.deleted||[]).map(a=>typeof a=="string"?a.trim().replace(/\\/g,"/"):"").filter(Boolean)),P=this.vault.getMarkdownFiles().filter(a=>this.inScope(a.path)).filter(a=>{let c=a.path.trim().replace(/\\/g,"/");return!m.has(c)&&!h.has(c)}),b=0;if(P.length)try{await this.pushAllNow(P),b=P.length}catch(a){console.error("[Flux] push local-only:",a),new u.Notice(`Flux: push failed \u2014 ${g(a)}`)}if(r||o||b){let a=[];r&&a.push(`${r} updated`),o&&a.push(`${o} deleted`),b&&a.push(`${b} pushed`),new u.Notice(`Flux: synced \u2014 ${a.join(", ")}`)}}catch(s){if(s.name==="AbortError")return;console.error("[Flux] pull error:",s),new u.Notice(`Flux: pull failed \u2014 ${g(s)}`)}}}cancel(){var e;(e=this.abortController)==null||e.abort();for(let t of this.pushDebounce.values())clearTimeout(t);this.pushDebounce.clear()}handleCreate(e){e instanceof u.TFile&&this.pushFile(e)}handleModify(e){e instanceof u.TFile&&this.pushFile(e)}async handleRename(e,t){if(this.applyingPull||!this.settings.enabled||!this.baseUrl)return;let n=this.inScope(t),s=e instanceof u.TFile&&this.inScope(e.path);if(!n&&!s)return;let i=n?[t]:[],r=[];if(s){let o=await this.vault.read(e);r.push({path:e.path,content:o,hash:v(o)})}try{let o=await this.api("/push",{method:"POST",body:JSON.stringify({files:r,deleted:i})});if(!o.ok)throw new Error(`Push failed: ${o.status}`);new u.Notice(`Flux: synced rename \u2192 ${e.path}`)}catch(o){console.error("[Flux] rename push error:",o),new u.Notice(`Flux: rename failed \u2014 ${g(o)}`)}}async handleDelete(e){if(!(this.applyingPull||!this.settings.enabled||!this.baseUrl||!this.inScope(e.path)))try{let t=await this.api("/push",{method:"POST",body:JSON.stringify({files:[],deleted:[e.path]})});if(!t.ok)throw new Error(`Push failed: ${t.status}`);new u.Notice(`Flux: deleted ${e.path}`)}catch(t){console.error("[Flux] delete push error:",t),new u.Notice(`Flux: delete failed \u2014 ${g(t)}`)}}};var S=class extends y.Plugin{constructor(){super(...arguments);this.sync=null;this.pullInterval=null}async onload(){await this.loadSettings(),this.addCommand({id:"flux-sync",name:"Sync",callback:()=>this.syncNow()}),this.addCommand({id:"flux-pull",name:"Pull changes",callback:()=>this.pull()}),this.addCommand({id:"flux-push",name:"Push all changes",callback:()=>this.pushAll()}),this.addSettingTab(new F(this.app,this)),this.sync=new x(this.settings,this.app.vault),this.settings.enabled&&this.startSync()}onunload(){var t;(t=this.sync)==null||t.cancel(),this.clearPullInterval()}async loadSettings(){this.settings={...N,...await this.loadData()}}async saveSettings(){await this.saveData(this.settings)}setSyncEnabled(t){t?this.startSync():this.stopSync()}restartPullInterval(){this.clearPullInterval(),this.settings.enabled&&this.settings.syncIntervalSeconds>0&&(this.pullInterval=setInterval(()=>this.pull(),this.settings.syncIntervalSeconds*1e3))}async startSync(){if(!this.sync)return;this.sync.updateSettings(this.settings);let t=(this.settings.fluxFolder||"").trim().replace(/^\/|\/$/g,"");t&&!this.app.vault.getAbstractFileByPath(t)&&await this.app.vault.createFolder(t),await this.pull();let n=this.app.vault.getMarkdownFiles().filter(s=>this.sync.inScope(s.path));if(n.length)try{await this.sync.pushAllNow(n)}catch(s){console.error("[Flux] initial push:",s),new y.Notice(`Flux: initial push failed \u2014 ${s instanceof Error?s.message:String(s)}`)}this.registerEvent(this.app.vault.on("create",s=>this.sync.handleCreate(s))),this.registerEvent(this.app.vault.on("modify",s=>this.sync.handleModify(s))),this.registerEvent(this.app.vault.on("rename",(s,i)=>this.sync.handleRename(s,i))),this.registerEvent(this.app.vault.on("delete",s=>this.sync.handleDelete(s))),this.restartPullInterval()}stopSync(){var t;(t=this.sync)==null||t.cancel(),this.clearPullInterval()}clearPullInterval(){this.pullInterval&&(clearInterval(this.pullInterval),this.pullInterval=null)}async syncNow(){await this.pull(),await this.pushAll()}pull(){var t;return(t=this.sync)==null?void 0:t.pull()}async pushAll(){if(!this.sync)return;let t=this.app.vault.getMarkdownFiles().filter(n=>this.sync.inScope(n.path));await this.sync.pushFiles(t),new y.Notice("Flux: pushed all files")}};
